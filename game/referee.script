local groups = require "game.groups"
local messages = require "game.messages"
local logger = require "ludobits.m.logger"
local sequence = require "ludobits.m.sequence"

local log = logger.create("[referee]")

local function play_flipbook(self, anim)
	if self.current_animation ~= anim then
		self.current_animation = anim
		sprite.play_flipbook("#sprite", anim)
	end
end

function init(self)
	self.speed = 30
	self.champs = {}
end

function update(self, dt)
	if self.idle then
		return
	end
	
	-- calculate a mid position for all champs
	local mid = vmath.vector3()
	local count = 1
	for champ,_ in pairs(self.champs) do
		mid = mid + go.get_position(champ)
		count = count + 1
	end
	mid.x = mid.x / count
	mid.y = mid.y / count
	mid.z = 0

	-- position referee offset from the mid position
	local pos = go.get_position()
	local a = math.atan2(mid.y - pos.y, mid.x - pos.x)
	local target = mid + vmath.vector3(math.sin(a), math.cos(a), 0) * 40

	local diff = target - pos
	local dir = vmath.normalize(diff)
	local distance = vmath.length(diff)
	if distance > 5 then
		play_flipbook(self, "referee_walk")
		pos = pos + dir * self.speed * dt
		pos.z = 1 - pos.y / 640
		go.set_position(pos)
	else
		log("idle")
		sequence.run_once(function()
			self.idle = true
			play_flipbook(self, "referee_idle")
			sequence.delay(0.8)
			self.idle = false
		end)
	end
end

function on_message(self, message_id, message, sender)
	if message_id == messages.CONTACT_POINT_RESPONSE then
		if message.other_group == groups.ROPE or message.other_group == groups.POST then
			if message.distance > 0 then
				go.set_position(go.get_position() + message.normal * message.distance)
			end
		end
	elseif message_id == messages.TRIGGER_RESPONSE then
		if message.other_group == groups.CHAMP then
			if message.enter then
				self.champs[message.other_id] = true
			else
				self.champs[message.other_id] = nil
			end
		end
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
