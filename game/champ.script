go.property("player", true)
go.property("id", 1)
go.property("champ", hash("terry_brogan"))

go.property("initial_stamina", 100)
go.property("current_stamina", 100)
go.property("initial_max_speed", 50)
go.property("current_max_speed", 50)
go.property("initial_speed_lerp", 0.85)
go.property("current_speed_lerp", 0.85)
go.property("acceleration", 250)

local mapper = require "in.mapper"
local state = require "in.state"
local actions = require "game.actions"
local directions = require "game.directions"
local util = require "ludobits.m.util"
local sequence = require "ludobits.m.sequence"
local champs = require "game.champs"
local logger = require "ludobits.m.logger"

local log = nil

local GROUP_ROPE = hash("rope")
local GROUP_CHAMP = hash("champ")
local GROUP_ATTACK = hash("attack")

local MSG_CONTACT_POINT_RESPONSE = hash("contact_point_response")
local MSG_TRIGGER_RESPONSE = hash("trigger_response")
local MSG_DOWN = hash("down")
local MSG_DAMAGE = hash("damage")
local MSG_LIFTED = hash("lifted")
local MSG_THROWN = hash("thrown")

local RUN_RATIO = 2
local ROPE_BOUNCE_RATIO = 4

local V3_ZERO = vmath.vector3(0)
local V3_ONE = vmath.vector3(1)

local CHAMPS = {}

local function get_champ(id)
	return CHAMPS[id or go.get_id()]
end

local function is_stunned(id)
	return get_champ(id).stunned
end

local function is_down(id)
	return get_champ(id).down
end

local function is_moving(id)
	return not is_stunned(id) and not is_down(id) and vmath.length(get_champ(id).speed) > 1
end

local function is_running(id)
	return get_champ(id).running
end

local function is_attacking(id)
	return get_champ(id).attacking
end

local function is_lifting_champ(id)
	return get_champ(id).lifting_champ
end

local function is_idle(id)
	return not is_moving(id)
	and not is_attacking(id)
	and not is_down(id)
	and not is_running(id)
end

local function stop(self)
	log("stop")
	self.running = false
	self.speed.x = 0
	self.speed.y = 0
	self.current_max_speed = self.initial_max_speed
	self.current_speed_lerp = self.initial_speed_lerp
end

local function play_flipbook(self, name)
	local animation = self.champ_data[name]
	if self.current_animation ~= animation then
		log("playing", animation)
		self.current_animation = animation
		sprite.play_flipbook("#sprite", animation)
	end
end

local function disable(url)
	msg.post(url, "disable")
end

local function enable(url)
	msg.post(url, "enable")
end

local function enable_side(self, left, right)
	msg.post(self.direction.x == -1 and left or right, "enable")
end

local function update_sprite_flip(self)
	sprite.set_hflip("#sprite", self.direction.x == -1)
end

local function update_hud(self)
	msg.post("hud", "champ", {
		id = self.id,
		champ = self.champ,
		health = self.current_stamina / self.initial_stamina,
	})
end

local function direction(go1, go2)
	local diff = go.get_position(go2) - go.get_position(go1)
	if vmath.length(diff) == 0 then
		return V3_ZERO
	else
		return vmath.normalize(diff)
	end
end


local function throw_champ(self)
	if is_lifting_champ(id) then
		sequence.run_once(function()
			log("throw")
			local pos = go.get_position()
			local champ = self.lifting_champ
			self.lifting_champ = nil
			go.set_parent(champ, nil, true)
			if self.direction.x ~= 0 then
				go.animate(champ, "position.x", go.PLAYBACK_ONCE_FORWARD, pos.x + 40 * self.direction.x, go.EASING_OUTQUAD, 0.35)
				go.animate(champ, "position.y", go.PLAYBACK_ONCE_FORWARD, pos.y, go.EASING_OUTBOUNCE, 0.35)
			else
				go.animate(champ, "position.y", go.PLAYBACK_ONCE_FORWARD, pos.y + 40 * self.direction.y, go.EASING_OUTBOUNCE, 0.35)
			end
			sequence.delay(0.35)
			msg.post(champ, MSG_THROWN)
		end)
	end
end

local function handle_action(self, action_id, action)
	self.state.on_input(action_id, action)

	if self.stunned then
		return
	end

	local now = socket.gettime()

	-- run
	if actions.is_movement(action_id) and action.pressed then
		-- stop running if trying to move again in other direction
		if self.running then
			if self.speed.x > 0 and action_id ~= actions.RIGHT
			or self.speed.x < 0 and action_id ~= actions.LEFT
			or self.speed.y > 0 and action_id ~= actions.UP
			or self.speed.y < 0 and action_id ~= actions.DOWN then
				stop(self)
			end
		end
		-- double tap to run
		if self.last_action == action_id and (now - self.last_action_time) < 0.3 then
			log("run")
			sequence.run_once(function()
				self.running = true
				self.current_max_speed = self.initial_max_speed * RUN_RATIO
				self.speed = actions.direction(action_id) * self.current_max_speed
				self.current_speed_lerp = 0
				if self.run_timer then
					timer.cancel(self.run_timer)
				end
			end)
		end
	-- punch
	elseif action_id == actions.A then
		if action.pressed then
			local nearby = next(self.nearby)
			if is_lifting_champ(id) then
				throw_champ(self)
			elseif nearby and is_down(nearby) then
				log("lifing champ")
				msg.post(nearby, MSG_LIFTED)
				self.lifting_champ = nearby
				go.set_parent(nearby, go.get_id(), false)
				go.set_position(vmath.vector3(0, 14, 0), nearby)
			else
				log("punch")
				sequence.run_once(function()
					if self.attacking then
						return
					end
					if not self.running then
						stop(self)
					end
					self.attacking = true
					enable_side(self, "#leftattack", "#rightattack")
					play_flipbook(self, "punch")
					sequence.go_animate(".", "position", go.PLAYBACK_ONCE_FORWARD, go.get_position() + self.direction * 5, go.EASING_INQUAD, 0.1)
					sequence.delay(0.1)
					disable("#leftattack")
					disable("#rightattack")
					self.attacking = false
				end)
			end
		end
	-- kick
	elseif action_id == actions.B and action.pressed then
		sequence.run_once(function()
			self.attacking = true
			stop(self)
			enable_side(self, "#leftattack", "#rightattack")
			play_flipbook(self, "kick")
			sequence.delay(1.0)
			disable("#leftattack")
			disable("#rightattack")
			self.attacking = false
		end)
	end

	-- update last action
	if action.pressed then
		self.last_action_time = now
		self.last_action = action_id
	end
end

local function start_ai(self)
	local target = nil
	sequence.run_loop(function()
		if is_down() then
			sequence.delay(0.5)
			return
		end
		
		if not target then
			target = CHAMPS[math.random(1, #CHAMPS)]
			if target.id == go.get_id() or is_down(target.id) then
				target = nil
			end
		end
		if not target then
			sequence.delay(0.5)
			return
		end

		local pos = go.get_position()
		local target_pos = go.get_position(target.id)
		local diff = target_pos - pos
		local distance = vmath.length(diff)
		local dir = vmath.normalize(diff)
		if distance < 15 then
			handle_action(self, actions.LEFT, actions.ACTION_RELEASED)
			handle_action(self, actions.RIGHT, actions.ACTION_RELEASED)
			target = nil
			handle_action(self, actions.A, actions.ACTION_PRESSED)
			handle_action(self, actions.A, actions.ACTION_RELEASED)
		else
			if dir.x > 0 then
				handle_action(self, actions.RIGHT, actions.ACTION_PRESSED)
				handle_action(self, actions.LEFT, actions.ACTION_RELEASED)
			elseif dir.x < 0 then
				handle_action(self, actions.LEFT, actions.ACTION_PRESSED)
				handle_action(self, actions.RIGHT, actions.ACTION_RELEASED)
			else
				handle_action(self, actions.LEFT, actions.ACTION_RELEASED)
				handle_action(self, actions.RIGHT, actions.ACTION_RELEASED)
			end
			if dir.y > 0 then
				handle_action(self, actions.UP, actions.ACTION_PRESSED)
				handle_action(self, actions.DOWN, actions.ACTION_RELEASED)
			elseif dir.y < 0 then
				handle_action(self, actions.DOWN, actions.ACTION_PRESSED)
				handle_action(self, actions.UP, actions.ACTION_RELEASED)
			else
				handle_action(self, actions.UP, actions.ACTION_RELEASED)
				handle_action(self, actions.DOWN, actions.ACTION_RELEASED)
			end
		end
		sequence.delay(0.25)
	end)
end

local function take_damage(self, amount, source, props)
	self.current_stamina = math.max(self.current_stamina - amount, 0)
	if self.current_stamina == 0 then
		sequence.run_once(function()
			log("down")
			self.down = true
			throw_champ(self)
			play_flipbook(self, "down")
			sequence.go_animate("#", "current_stamina", go.PLAYBACK_ONCE_FORWARD, self.initial_stamina, go.EASING_LINEAR, 5)
			play_flipbook(self, "idle")
			self.down = false
		end)
	end
	update_hud(self)

	-- stun
	sequence.run_once(function()
		self.stunned = true
		local left = (go.get_position() - go.get_position(source)).x > 0
		enable(left and "#lefthit" or "#righthit")
		sequence.delay(0.15)
		disable(left and "#lefthit" or "#righthit")
		self.stunned = false
	end)

	-- pushback
	sequence.run_once(function()
		self.current_max_speed = self.initial_max_speed * 2
		self.current_speed_lerp = 0
		self.speed = (props.pushback or V3_ONE) * self.current_max_speed
		sequence.delay(0.1)
		self.current_speed_lerp = self.initial_speed_lerp
		self.current_max_speed = self.initial_max_speed
	end)
end

function init(self)
	log = logger.create("[champ_" .. self.id .. "]")
	log(self.player, self.id, self.champ)
	CHAMPS[go.get_id()] = self
	CHAMPS[#CHAMPS + 1] = { id = go.get_id(), instance = self }
	self.nearby = {}
	self.last_action_time = nil
	self.last_action = nil
	self.direction = directions.NONE
	self.state = state.create()
	self.speed = vmath.vector3()
	self.current_speed_lerp = self.initial_speed_lerp
	self.current_max_speed = self.initial_max_speed
	self.current_stamina = self.initial_stamina
	self.champ_data = champs.get(self.champ)
	disable("#leftattack")
	disable("#rightattack")
	disable("#lefthit")
	disable("#righthit")
	if self.player then
		msg.post(".", "acquire_input_focus")
	end
	sequence.run_once(function()
		sequence.delay(math.random() * 0.25)
		play_flipbook(self, "idle")
	end)
	update_hud(self)

	if not self.player then
		start_ai(self)
	end
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	local can_move = not is_attacking() and not is_stunned() and not is_down()
	if self.state.is_pressed(actions.LEFT) and can_move then
		self.speed.x = self.speed.x - self.acceleration * dt
		self.direction = directions.LEFT
		update_sprite_flip(self)
	elseif self.state.is_pressed(actions.RIGHT) and can_move then
		self.speed.x = self.speed.x + self.acceleration * dt
		self.direction = directions.RIGHT
		update_sprite_flip(self)
	else
		self.speed.x = vmath.lerp(self.current_speed_lerp, self.speed.x, 0)
	end

	if self.state.is_pressed(actions.UP) and can_move then
		self.speed.y = self.speed.y + self.acceleration * dt
		self.direction = directions.UP
	elseif self.state.is_pressed(actions.DOWN) and can_move then
		self.speed.y = self.speed.y - self.acceleration * dt
		self.direction = directions.DOWN
	else
		self.speed.y = vmath.lerp(self.current_speed_lerp, self.speed.y, 0)
	end

	if not is_attacking() then
		if is_idle() then
			play_flipbook(self, is_lifting_champ() and "idle_lifting" or "idle")
		elseif is_moving() then
			play_flipbook(self, is_lifting_champ() and "walk_lifting" or "walk")
		end
	end

	-- clamp to max speed
	self.speed.x = util.clamp(self.speed.x, -self.current_max_speed, self.current_max_speed)
	self.speed.y = util.clamp(self.speed.y, -self.current_max_speed, self.current_max_speed)

	local pos = go.get_position()
	pos = pos + self.speed * dt
	pos.z = 1 - pos.y / 640
	go.set_position(pos)
	update_hud(self)
end

function on_message(self, message_id, message, sender)
	if message_id == MSG_CONTACT_POINT_RESPONSE then
		-- this champ ran into the rope
		if message.other_group == GROUP_ROPE then
			if message.distance > 0 then
				-- bounce on the rope
				if is_running() then
					-- increase speed and animate back to previous speed
					local current_max_speed = self.current_max_speed
					self.current_max_speed = self.initial_max_speed * ROPE_BOUNCE_RATIO
					go.animate("#", "current_max_speed", go.PLAYBACK_ONCE_FORWARD, current_max_speed, go.EASING_LINEAR, 0.5)
					-- flip direction
					local horizontal = math.abs(message.normal.x) > math.abs(message.normal.y)
					if horizontal then
						self.speed.x = (message.normal.x > 0) and self.current_max_speed or -self.current_max_speed
						self.direction = (message.normal.x > 0) and directions.RIGHT or directions.LEFT
						update_sprite_flip(self)
					else
						self.speed.y = (message.normal.y > 0) and self.current_max_speed or -self.current_max_speed
						self.direction = (message.normal.y > 0) and directions.UP or directions.DOWN
					end
					-- stop running after a certain period of time has elapsed
					self.run_timer = timer.delay(0.6, false, function()
						stop(self)
						self.running = false
					end)
				-- stop at the rope
				else
					go.set_position(go.get_position() + message.normal * message.distance)
				end
			end
		-- this champ hit another champ
		elseif message.own_group == GROUP_ATTACK and message.other_group == GROUP_CHAMP and is_attacking() then
			local dir = direction(go.get_id(), message.other_id)
			if is_running() then
				log("clothesline!")
				msg.post(message.other_id, MSG_DAMAGE, { amount = 30, pushback = dir })
			else
				log("hit!")
				msg.post(message.other_id, MSG_DAMAGE, { amount = 10, pushback = dir })
				stop(self)
			end
			self.attacking = false
		end
	elseif message_id == MSG_TRIGGER_RESPONSE then
		if go.get_id() ~= message.other_id then
			if message.enter then
				self.nearby[message.other_id] = true
			else
				self.nearby[message.other_id] = nil
			end
		end
	elseif message_id == MSG_DAMAGE then
		take_damage(self, message.amount, sender, message)
	elseif message_id == MSG_LIFTED then
		log("lifted")
		disable("#shadow")
		disable("#champcollider")
	elseif message_id == MSG_THROWN then
		log("thrown")
		enable("#shadow")
		enable("#champcollider")
	end
end

function on_input(self, action_id, action)
	action_id = mapper.on_input(action_id, self.id)
	handle_action(self, action_id, action)
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
