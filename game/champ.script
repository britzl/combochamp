go.property("index", 1)
go.property("champ", hash("terry_brogan"))
go.property("team", 1)
go.property("controls", hash(""))
go.property("gamepad", 1)

go.property("initial_stamina", 100)
go.property("current_stamina", 100)
go.property("initial_max_speed", 50)
go.property("current_max_speed", 50)
go.property("initial_speed_lerp", 0.85)
go.property("current_speed_lerp", 0.85)
go.property("acceleration", 250)

local logger = require "ludobits.m.logger"
local util = require "ludobits.m.util"
local sequence = require "ludobits.m.sequence"

local mapper = require "in.mapper"
local state = require "in.state"
local triggers = require "in.triggers"

local actions = require "game.actions"
local directions = require "game.directions"
local champs = require "game.champs"
local controls = require "game.controls"
local sounds = require "game.sounds"
local groups = require "game.groups"
local messages = require "game.messages"

local log = nil

local BOOST_THROW = 5
local BOOST_NORMAL_DAMAGE = 2
local BOOST_SPECIAL_DAMAGE = 10
local BOOST_TAUNT = 1
local BOOST_CLIMB_RING_POST = 2
local BOOST_BOUNCE_ROPE = 2

local RING_POST_TOPLEFT = hash("/post_topleft")
local RING_POST_TOPRIGHT = hash("/post_topright")
local RING_POST_BOTTOMLEFT = hash("/post_bottomleft")
local RING_POST_BOTTOMRIGHT = hash("/post_bottomright")

local RUN_RATIO = 4
local ROPE_BOUNCE_RATIO = 8

local V3_ZERO = vmath.vector3(0)
local V3_ONE = vmath.vector3(1)
local V3_TOPLEFT = vmath.vector3(-1, 1, 0)
local V3_TOPRIGHT = vmath.vector3(1, 1, 0)
local V3_BOTTOMLEFT = vmath.vector3(-1, -0.5, 0)
local V3_BOTTOMRIGHT = vmath.vector3(1, -0.5, 0)

local POST_TO_DIRECTION = {
	[RING_POST_TOPLEFT] = V3_TOPLEFT,
	[RING_POST_TOPRIGHT] = V3_TOPRIGHT,
	[RING_POST_BOTTOMLEFT] = V3_BOTTOMLEFT,
	[RING_POST_BOTTOMRIGHT] = V3_BOTTOMRIGHT,
}

local REFEREE = hash("/referee")

local CHAMPS = {
	all = {},
	lookup = {},
}

local function get_champ(id)
	return CHAMPS.lookup[id or go.get_id()]
end

local function random_champ()
	return CHAMPS.all[math.random(1, #CHAMPS.all)]
end

local function is_stunned(id) return get_champ(id).stunned end
local function is_in_ring(id) return get_champ(id).in_ring end
local function is_on_ring_post(id) return get_champ(id).on_ring_post end
local function is_down(id) return get_champ(id).down end
local function is_running(id) return get_champ(id).running end
local function is_attacking(id) return get_champ(id).attacking end
local function is_lifting_champ(id) return get_champ(id).lifting_champ end
local function is_lifting_chair(id) return get_champ(id).lifting_chair end
local function is_lifted(id) return get_champ(id).lifted end
local function is_pinned(id) return get_champ(id).pinned end
local function is_jumping(id) return get_champ(id).jumping end
local function is_busy(id) return get_champ(id).busy end
local function is_opponent(id) return get_champ().team ~= get_champ(id).team end
local function is_me(id) return get_champ().id == id end
local function is_moving(id)
	return not is_stunned(id)
	and not is_down(id)
	and vmath.length(get_champ(id).speed) > 1
end
local function is_idle(id)
	return not is_moving(id)
	and not is_attacking(id)
	and not is_down(id)
	and not is_running(id)
	and not is_stunned(id)
	and not is_busy(id)
end

local function stop(self)
	log("stop")
	self.running = false
	self.speed.x = 0
	self.speed.y = 0
	self.current_max_speed = self.initial_max_speed
	self.current_speed_lerp = self.initial_speed_lerp
end

local function play_flipbook(self, name)
	local animation = self.champ_data[name]
	if self.current_animation ~= animation then
		log("playing", animation)
		self.current_animation = animation
		sprite.play_flipbook("#sprite", animation)
	end
end

local function disable(url)
	msg.post(url, "disable")
end

local function enable(url)
	msg.post(url, "enable")
end

local function enable_side(self, left, right)
	msg.post(self.direction.x == -1 and left or right, "enable")
end

local function update_sprite_flip(self)
	sprite.set_hflip("#sprite", self.direction.x == -1)
end

local function update_hud(self)
	msg.post("hud", "champ", {
		index = self.index,
		champ = self.champ,
		boost = self.current_boost / self.max_boost,
		health = self.current_stamina / self.initial_stamina,
		health_max = self.max_stamina / self.initial_stamina,
		in_ring = self.in_ring,
	})
end

local function direction(go1, go2)
	local diff = go.get_position(go2) - go.get_position(go1)
	if vmath.length(diff) == 0 then
		return V3_ZERO
	else
		return vmath.normalize(diff)
	end
end

local function increase_boost(self, amount)
	self.current_boost = math.min(self.current_boost + amount, self.max_boost)
	update_hud(self)
end

local function throw_champ(self)
	if is_lifting_champ() then
		sequence.run_once(function()
			log("throw champ")
			sounds.thud()
			increase_boost(self, BOOST_THROW)
			local pos = go.get_position()
			local champ = self.lifting_champ
			self.lifting_champ = nil
			go.set_parent(champ, nil, true)
			if self.direction.x ~= 0 then
				go.animate(champ, "position.x", go.PLAYBACK_ONCE_FORWARD, pos.x + 40 * self.direction.x, go.EASING_OUTQUAD, 0.35)
				go.animate(champ, "position.y", go.PLAYBACK_ONCE_FORWARD, pos.y, go.EASING_OUTBOUNCE, 0.35)
			else
				go.animate(champ, "position.y", go.PLAYBACK_ONCE_FORWARD, pos.y + 40 * self.direction.y, go.EASING_OUTBOUNCE, 0.35)
			end
			sequence.delay(0.35)
			msg.post(champ, messages.THROWN)
		end)
	end
end


local function throw_chair(self)
	if is_lifting_chair() then
		local chair = self.lifting_chair
		self.lifting_chair = nil
		self.thrown_chairs[chair] = true
		go.set_parent(chair, nil, true)
		sequence.run_once(function()
			log("throw chair")
			increase_boost(self, BOOST_THROW)
			local pos = go.get_position()
			sequence.delay(0)
			msg.post(chair, messages.THROWN)
			if self.direction.x ~= 0 then
				go.set_rotation(vmath.quat_rotation_z(math.rad(-90 * self.direction.x)), chair)
				sequence.go_animate(chair, "position.x", go.PLAYBACK_ONCE_FORWARD, pos.x + 300 * self.direction.x, go.EASING_LINEAR, 1.5)
			else
				sequence.go_animate(chair, "position.y", go.PLAYBACK_ONCE_FORWARD, pos.y + 300 * self.direction.y, go.EASING_LINEAR, 1.5)
			end
			self.thrown_chairs[chair] = nil
			go.delete(chair)
		end)
	end
end

local function lift_champ(self, champ)
	log("lifing champ")
	msg.post(champ, messages.LIFTED)
	self.lifting_champ = champ
	go.set_parent(champ, go.get_id(), false)
	go.set_position(vmath.vector3(0, 14, 0), champ)
end

local function lift_chair(self, chair)
	log("lifing chair")
	assert(not self.lifting_chair)
	assert(chair)
	msg.post(chair, messages.LIFTED)
	self.lifting_chair = chair
	go.set_parent(chair, go.get_id(), false)
	go.set_position(vmath.vector3(0, 17, 0), chair)
end

local function climb_ring_post(self, post)
	sequence.run_once(function()
		throw_champ(self)
		throw_chair(self)
		increase_boost(self, BOOST_CLIMB_RING_POST)
		self.busy = true
		self.on_ring_post = true
		self.ring_post_id = post
		stop(self)
		local to = go.get_world_position(post) + vmath.vector3(0, 5, 0)
		sequence.go_animate(".", "position", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_LINEAR, 0.2)
		disable("#shadow")
		disable("#champcollider")
		self.busy = false
	end)
end

local function jump_from_ring_post(self)
	enable("#champcollider")
	sequence.run_once(function()
		self.jumping = true
		self.on_ring_post = false

		play_flipbook(self, "back")

		-- jump animation
		-- different easings on x and y will make the movement in an arc instead of
		-- a straight line
		local to = go.get_position()
		local dir = POST_TO_DIRECTION[self.ring_post_id]
		to = to - dir * 30
		if dir.y < 0 then
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, to.x, go.EASING_LINEAR, 0.2)
			go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, to.y, go.EASING_OUTQUAD, 0.2)
		else
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, to.x, go.EASING_LINEAR, 0.2)
			go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, to.y, go.EASING_INQUAD, 0.2)
			sprite.set_vflip("#sprite", true)
		end
		sequence.delay(0.2)

		-- bounce when landing and enable special attack
		sounds.thud()
		to = to + vmath.vector3(0,5,0)
		enable("#specialattack")
		self.attacking = true
		sequence.go_animate(".", "position", go.PLAYBACK_ONCE_PINGPONG, to, go.EASING_INOUTQUAD, 0.1)
		self.attacking = false
		disable("#specialattack")

		-- delay before standing up
		sequence.delay(0.5)
		sprite.set_vflip("#sprite", false)
		enable("#shadow")
		self.jumping = false
	end)
end

local function attack(self)
	log("punch")
	sequence.run_once(function()
		if not is_running() then
			stop(self)
		end
		self.attacking = true
		sounds.miss()
		enable_side(self, "#leftattack", "#rightattack")
		play_flipbook(self, "punch")
		sequence.go_animate(".", "position", go.PLAYBACK_ONCE_FORWARD, go.get_position() + self.direction * 5, go.EASING_INQUAD, 0.1)
		sequence.delay(0.1)
		disable("#leftattack")
		disable("#rightattack")
		self.attacking = false
	end)
end


local function taunt(self)
	log("taunt")
	sequence.run_once(function()
		increase_boost(self, BOOST_TAUNT)
		self.busy = true
		stop(self)
		play_flipbook(self, "taunt")
		sequence.delay(1)
		self.busy = false
	end)
end


local function unpin(self)
	log("unpin")
	msg.post(REFEREE, messages.CHAMP_UNPINNED, { champ = go.get_id() })
	self.pinned = false
	self.down = false
end

local function pin(self, champ)
	log("pin", champ)
	-- pin opponent
	sequence.run_once(function()
		self.busy = true
		local me = go.get_id()
		get_champ(champ).pinned = me
		stop(self)
		local to = go.get_position(champ)
		to.y = to.y - 1
		go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, to.x, go.EASING_INOUTQUAD, 0.3)
		go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, to.y, go.EASING_OUTBOUNCE, 0.5)
		play_flipbook(self, "back")
		msg.post(REFEREE, messages.CHAMP_PINNED, { champ = me, pinned = champ })
		sequence.wait_until_false(function() return is_pinned(champ) end)
		self.busy = false
	end)
end

local function handle_action(self, action_id, action)
	self.state.on_input(action_id, action)

	if is_stunned() or is_down() or is_busy() then
		return
	end

	local now = socket.gettime()

	-- run
	if actions.is_movement(action_id) and not is_on_ring_post() and action.pressed then
		-- stop running if trying to move again in other direction
		if is_running() then
			if self.speed.x > 0 and action_id ~= actions.RIGHT
			or self.speed.x < 0 and action_id ~= actions.LEFT
			or self.speed.y > 0 and action_id ~= actions.UP
			or self.speed.y < 0 and action_id ~= actions.DOWN then
				stop(self)
			end
		end
		-- double tap to run
		if self.last_action == action_id and (now - self.last_action_time) < 0.3 then
			log("run")
			sequence.run_once(function()
				self.running = true
				self.current_max_speed = self.initial_max_speed * RUN_RATIO
				self.speed = actions.direction(action_id) * self.current_max_speed
				self.current_speed_lerp = 0
				if self.run_timer then
					timer.cancel(self.run_timer)
				end
			end)
		end
	-- punch
	elseif action_id == actions.A then
		if action.pressed then
			local nearby = next(self.nearby_champ)
			if is_lifting_champ() then
				throw_champ(self)
			elseif is_lifting_chair() then
				throw_chair(self)
			elseif nearby and is_down(nearby) and not is_pinned(nearby) and not is_lifting_chair() then
				lift_champ(self, nearby)
			elseif is_on_ring_post() then
				jump_from_ring_post(self)
			elseif not is_attacking() then
				attack(self)
			end
		end
	elseif action_id == actions.B then
		if action.pressed then
			local nearby = next(self.nearby_champ)
			if not nearby then
				taunt(self)
			elseif is_down(nearby) then
				pin(self, nearby)
			end
		end
	end

	-- update last action
	if action.pressed then
		self.last_action_time = now
		self.last_action = action_id
	end
end

local function start_ai(self)
	local target = nil
	sequence.run_loop(function()
		if is_down() or is_lifted() or is_pinned() then
			sequence.delay(0.5)
			return
		end
		
		if not target then
			target = random_champ()
			if target.id == self.id
			or target.team == self.team
			or is_down(target.id)
			or is_on_ring_post(target.id) then
				target = nil
			end
		end
		if not target then
			sequence.delay(0.5)
			return
		end

		local pos = go.get_position()
		local target_pos = go.get_position(target.id)
		local diff = target_pos - pos
		local distance = vmath.length(diff)
		local dir = vmath.normalize(diff)
		if distance < 15 or is_on_ring_post() then
			handle_action(self, actions.LEFT, actions.ACTION_RELEASED)
			handle_action(self, actions.RIGHT, actions.ACTION_RELEASED)
			target = nil
			handle_action(self, actions.A, actions.ACTION_PRESSED)
			handle_action(self, actions.A, actions.ACTION_RELEASED)
		elseif math.random(1,10) == 9 then
			handle_action(self, actions.B, actions.ACTION_PRESSED)
			handle_action(self, actions.B, actions.ACTION_RELEASED)
		else
			if dir.x > 0 then
				handle_action(self, actions.RIGHT, actions.ACTION_PRESSED)
				handle_action(self, actions.LEFT, actions.ACTION_RELEASED)
			elseif dir.x < 0 then
				handle_action(self, actions.LEFT, actions.ACTION_PRESSED)
				handle_action(self, actions.RIGHT, actions.ACTION_RELEASED)
			else
				handle_action(self, actions.LEFT, actions.ACTION_RELEASED)
				handle_action(self, actions.RIGHT, actions.ACTION_RELEASED)
			end
			if dir.y > 0 then
				handle_action(self, actions.UP, actions.ACTION_PRESSED)
				handle_action(self, actions.DOWN, actions.ACTION_RELEASED)
			elseif dir.y < 0 then
				handle_action(self, actions.DOWN, actions.ACTION_PRESSED)
				handle_action(self, actions.UP, actions.ACTION_RELEASED)
			else
				handle_action(self, actions.UP, actions.ACTION_RELEASED)
				handle_action(self, actions.DOWN, actions.ACTION_RELEASED)
			end
		end
		sequence.delay(0.25)
	end)
end

local function regenerate_damage(self, dt)
	if is_down() and self.max_stamina > 0 then
		local amount = self.max_stamina / 10
		self.current_stamina = math.min(self.current_stamina + amount * dt, self.max_stamina)
		if self.current_stamina == self.max_stamina then
			self.down = false
			if is_pinned() then
				unpin(self)
			elseif not is_lifted() then
				play_flipbook(self, "idle")
			end
		end
	else
		local amount = self.max_stamina / 30
		self.current_stamina = math.min(self.current_stamina + amount * dt, self.max_stamina)
	end
	update_hud(self)
end

local function take_damage(self, amount, source)
	if self.down then
		return
	end
	self.current_stamina = math.max(self.current_stamina - amount, 0)
	if self.current_stamina == 0 then
		self.max_stamina = math.max(self.max_stamina - self.initial_stamina * 0.2, 0)
		sequence.run_once(function()
			log("down")
			self.down = true
			throw_champ(self)
			throw_chair(self)
			play_flipbook(self, "down")
		end)
	end
	update_hud(self)
	sounds.cheer()

	local dir = direction(go.get_id(), source)
	if math.abs(dir.x) > math.abs(dir.y) then
		dir.y = 0
	else
		dir.x = 0
	end

	-- stun
	sequence.run_once(function()
		self.stunned = true
		local left = dir.x > 0
		enable(left and "#lefthit" or "#righthit")
		sequence.delay(0.25)
		disable(left and "#lefthit" or "#righthit")
		self.stunned = false
	end)

	-- pushback
	sequence.run_once(function()
		self.current_max_speed = self.initial_max_speed * 2 * math.sqrt(amount)
		self.current_speed_lerp = 0
		self.speed = dir * -self.current_max_speed
		sequence.delay(0.10)
		self.current_speed_lerp = self.initial_speed_lerp
		self.current_max_speed = self.initial_max_speed
	end)

	msg.post("game", "damage", { amount = amount })
end

function init(self)
	log = logger.create("[champ_" .. self.index .. "]")
	log(self.controls, self.index, self.champ)

	if self.controls == controls.KEYBOARD then
		mapper.bind(triggers.KEY_UP, actions.UP, self.index)
		mapper.bind(triggers.KEY_DOWN, actions.DOWN, self.index)
		mapper.bind(triggers.KEY_LEFT, actions.LEFT, self.index)
		mapper.bind(triggers.KEY_RIGHT, actions.RIGHT, self.index)
		mapper.bind(triggers.KEY_N, actions.A, self.index)
		mapper.bind(triggers.KEY_M, actions.B, self.index)
	elseif self.controls == controls.GAMEPAD then
		mapper.bind(triggers.GAMEPAD_LSTICK_LEFT, actions.LEFT, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_LPAD_LEFT, actions.LEFT, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_RSTICK_LEFT, actions.LEFT, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_LSTICK_RIGHT, actions.RIGHT, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_LPAD_RIGHT, actions.RIGHT, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_RSTICK_RIGHT, actions.RIGHT, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_LSTICK_DOWN, actions.DOWN, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_LPAD_DOWN, actions.DOWN, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_RSTICK_DOWN, actions.DOWN, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_LSTICK_UP, actions.UP, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_LPAD_UP, actions.UP, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_RSTICK_UP, actions.UP, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_LTRIGGER, actions.A, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_LSHOULDER, actions.A, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_RPAD_LEFT, actions.A, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_RTRIGGER, actions.B, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_RSHOULDER, actions.B, self.index, self.gamepad)
		mapper.bind(triggers.GAMEPAD_RPAD_RIGHT, actions.B, self.index, self.gamepad)
	end

	CHAMPS.lookup[go.get_id()] = self
	CHAMPS.all[#CHAMPS.all + 1] = self
	self.id = go.get_id()
	self.nearby_champ = {}
	self.thrown_chairs = {}
	self.in_ring = false
	self.last_action_time = nil
	self.last_action = nil
	self.direction = directions.NONE
	self.state = state.create()
	self.speed = vmath.vector3()
	self.current_speed_lerp = self.initial_speed_lerp
	self.current_max_speed = self.initial_max_speed
	self.current_stamina = self.initial_stamina
	self.max_stamina = self.initial_stamina
	self.current_boost = 0
	self.max_boost = 100
	self.champ_data = champs.get(self.champ)
	disable("#leftattack")
	disable("#rightattack")
	disable("#lefthit")
	disable("#righthit")
	disable("#specialattack")
	if self.controls ~= controls.CPU then
		msg.post(".", "acquire_input_focus")
	end
	sequence.run_once(function()
		sequence.delay(math.random() * 0.25)
		play_flipbook(self, "idle")
	end)
	update_hud(self)

	if self.controls == controls.CPU then
		start_ai(self)
	end
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	regenerate_damage(self, dt)
	local can_move = not is_attacking()
		and not is_stunned()
		and not is_down()
		and not is_on_ring_post()
		and not is_busy()
		and not is_lifted()

	if self.state.is_pressed(actions.LEFT) and can_move then
		self.speed.x = self.speed.x - self.acceleration * dt
		self.direction = directions.LEFT
		update_sprite_flip(self)
	elseif self.state.is_pressed(actions.RIGHT) and can_move then
		self.speed.x = self.speed.x + self.acceleration * dt
		self.direction = directions.RIGHT
		update_sprite_flip(self)
	else
		self.speed.x = vmath.lerp(self.current_speed_lerp, self.speed.x, 0)
	end

	if self.state.is_pressed(actions.UP) and can_move then
		self.speed.y = self.speed.y + self.acceleration * dt
		self.direction = directions.UP
	elseif self.state.is_pressed(actions.DOWN) and can_move then
		self.speed.y = self.speed.y - self.acceleration * dt
		self.direction = directions.DOWN
	else
		self.speed.y = vmath.lerp(self.current_speed_lerp, self.speed.y, 0)
	end

	if not is_attacking() and not is_jumping() then
		local lifting_something = is_lifting_champ() or is_lifting_chair()
		if is_on_ring_post() then
			play_flipbook(self, "taunt")
		elseif is_idle() then
			play_flipbook(self, lifting_something and "idle_lifting" or "idle")
		elseif is_moving() then
			--log("WALK DAMMIT", self.speed)
			play_flipbook(self, lifting_something and "walk_lifting" or "walk")
		end
	end

	-- clamp to max speed
	self.speed.x = util.clamp(self.speed.x, -self.current_max_speed, self.current_max_speed)
	self.speed.y = util.clamp(self.speed.y, -self.current_max_speed, self.current_max_speed)

	local pos = go.get_position()
	pos = pos + self.speed * dt
	pos.z = 1 - pos.y / 640
	if is_on_ring_post() then
		pos.z = pos.z + 5
	end
	go.set_position(pos)
	update_hud(self)
end

function on_message(self, message_id, message, sender)
	if message_id == messages.CONTACT_POINT_RESPONSE then
		-- this champ ran into the rope
		if message.other_group == groups.ROPE then
			if is_on_ring_post() or is_jumping() then
				return
			end
			if self.in_ring then
				if message.distance > 0 then
					-- bounce on the rope
					if is_running() then
						log("bounce on rope")
						increase_boost(self, BOOST_BOUNCE_ROPE)
						-- increase speed and animate back to previous speed
						local current_max_speed = self.current_max_speed
						self.current_max_speed = self.initial_max_speed * ROPE_BOUNCE_RATIO
						go.animate("#", "current_max_speed", go.PLAYBACK_ONCE_FORWARD, current_max_speed, go.EASING_LINEAR, 0.5)
						-- flip direction
						local horizontal = math.abs(message.normal.x) > math.abs(message.normal.y)
						if horizontal then
							self.speed.x = (message.normal.x > 0) and self.current_max_speed or -self.current_max_speed
							self.direction = (message.normal.x > 0) and directions.RIGHT or directions.LEFT
							update_sprite_flip(self)
						else
							self.speed.y = (message.normal.y > 0) and self.current_max_speed or -self.current_max_speed
							self.direction = (message.normal.y > 0) and directions.UP or directions.DOWN
						end
						-- stop running after a certain period of time has elapsed
						self.run_timer = timer.delay(0.6, false, function()
							stop(self)
							self.running = false
						end)
					-- stop at the rope
					else
						log("stop at rope")
						go.set_position(go.get_position() + message.normal * message.distance)
					end
				end
			-- get back into ring
			else
				log("climb in")
				sequence.run_once(function()
					self.busy = true
					disable("#champcollider")
					local pos = go.get_position()
					pos = pos - message.normal * 30
					sequence.go_animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_INOUTQUAD, 0.4)
					enable("#champcollider")
					self.busy = false
				end)
			end
		-- this champ hit another champ
		elseif message.own_group == groups.ATTACK
		and message.other_group == groups.CHAMP
		and is_attacking()
		and not is_down(message.other_id)
		and is_opponent(message.other_id) then
			local dir = direction(go.get_id(), message.other_id)
			if is_running() then
				log("clothesline!")
				sounds.punch()
				increase_boost(self, BOOST_SPECIAL_DAMAGE)
			else
				log("hit!")
				sounds.punch()
				increase_boost(self, BOOST_NORMAL_DAMAGE)
				stop(self)
			end
			self.attacking = false
		-- this champ hit another champ with a special attack
		elseif message.own_group == groups.SPECIAL
		and message.other_group == groups.CHAMP
		and not is_down(message.other_id)
		and is_opponent(message.other_id) then
			log("special!")
			sounds.punch()
			increase_boost(self, BOOST_SPECIAL_DAMAGE)
			self.attacking = false
		-- this champ was hit by a special attack
		elseif message.other_group == groups.SPECIAL then
			if not self.thrown_chairs[message.other_id] then
				log("hit by special")
				take_damage(self, 50, message.other_id)
			end
		-- this champ was hit by an attack
		elseif message.other_group == groups.ATTACK then
			take_damage(self, 10, message.other_id)
		-- this champ came in contact with the ring post
		elseif message.other_group == groups.POST then
			if not is_in_ring() then
				go.set_position(go.get_position() + message.normal * message.distance)
			elseif not is_on_ring_post() then
				climb_ring_post(self, message.other_id)
			end
		end
	elseif message_id == messages.TRIGGER_RESPONSE then
		-- nearby another champ
		if message.other_group == groups.CHAMP then
			if not is_me(message.other_id)
			and is_opponent(message.other_id) then
				if message.enter then
					self.nearby_champ[message.other_id] = true
				else
					self.nearby_champ[message.other_id] = nil
				end
			end
		-- inside ring
		elseif message.other_group == groups.RING then
			self.in_ring = message.enter
		elseif message.other_group == groups.CHAIR then
			if not is_lifting_chair()
			and not is_lifting_champ()
			and not is_down() then
				lift_chair(self, message.other_id)
			end
		end
	elseif message_id == messages.LIFTED then
		log("lifted")
		self.lifted = true
		disable("#shadow")
		disable("#champcollider")
	elseif message_id == messages.THROWN then
		log("thrown")
		self.lifted = false
		enable("#shadow")
		enable("#champcollider")
	elseif message_id == messages.GAME_OVER then
		log("game over")
		self.busy = true
	end
end

function on_input(self, action_id, action)
	action_id = mapper.on_input(action_id, self.index)
	handle_action(self, action_id, action)
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
