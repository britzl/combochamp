go.property("player", true)
go.property("id", 1)
go.property("champ", hash("terry_brogan"))

go.property("initial_stamina", 100)
go.property("current_stamina", 100)
go.property("initial_max_speed", 50)
go.property("current_max_speed", 50)
go.property("initial_speed_lerp", 0.85)
go.property("current_speed_lerp", 0.85)
go.property("acceleration", 250)

local mapper = require "in.mapper"
local state = require "in.state"
local actions = require "game.actions"
local directions = require "game.directions"
local util = require "ludobits.m.util"
local sequence = require "ludobits.m.sequence"
local champs = require "game.champs"
local logger = require "ludobits.m.logger"
local sounds = require "game.sounds"

local log = nil

local GROUP_ROPE = hash("rope")
local GROUP_POST = hash("post")
local GROUP_RING = hash("ring")
local GROUP_CHAMP = hash("champ")
local GROUP_ATTACK = hash("attack")
local GROUP_SPECIAL = hash("special")

local MSG_CONTACT_POINT_RESPONSE = hash("contact_point_response")
local MSG_TRIGGER_RESPONSE = hash("trigger_response")
local MSG_DOWN = hash("down")
local MSG_DAMAGE = hash("damage")
local MSG_LIFTED = hash("lifted")
local MSG_THROWN = hash("thrown")

local BOOST_THROW = 5
local BOOST_NORMAL_DAMAGE = 2
local BOOST_SPECIAL_DAMAGE = 10
local BOOST_TAUNT = 1
local BOOST_CLIMB_RING_POST = 2
local BOOST_BOUNCE_ROPE = 2

local RING_POST_TOPLEFT = hash("/post_topleft")
local RING_POST_TOPRIGHT = hash("/post_topright")
local RING_POST_BOTTOMLEFT = hash("/post_bottomleft")
local RING_POST_BOTTOMRIGHT = hash("/post_bottomright")

local RUN_RATIO = 4
local ROPE_BOUNCE_RATIO = 8

local V3_ZERO = vmath.vector3(0)
local V3_ONE = vmath.vector3(1)
local V3_TOPLEFT = vmath.vector3(-1, 1, 0)
local V3_TOPRIGHT = vmath.vector3(1, 1, 0)
local V3_BOTTOMLEFT = vmath.vector3(-1, -0.5, 0)
local V3_BOTTOMRIGHT = vmath.vector3(1, -0.5, 0)

local POST_TO_DIRECTION = {
	[RING_POST_TOPLEFT] = V3_TOPLEFT,
	[RING_POST_TOPRIGHT] = V3_TOPRIGHT,
	[RING_POST_BOTTOMLEFT] = V3_BOTTOMLEFT,
	[RING_POST_BOTTOMRIGHT] = V3_BOTTOMRIGHT,
}

local CHAMPS = {}

local function get_champ(id)
	return CHAMPS[id or go.get_id()]
end

local function is_stunned(id) return get_champ(id).stunned end
local function is_on_ring_post(id) return get_champ(id).on_ring_post end
local function is_down(id) return get_champ(id).down end
local function is_running(id) return get_champ(id).running end
local function is_attacking(id) return get_champ(id).attacking end
local function is_lifting_champ(id) return get_champ(id).lifting_champ end
local function is_jumping(id) return get_champ(id).jumping end
local function is_busy(id) return get_champ(id).busy end
local function is_moving(id)
	local speed = get_champ(id).speed
	return not is_stunned(id)
	and not is_down(id)
	and (speed.x ~= 0 or speed.y ~= 0)
end
local function is_idle(id)
	return not is_moving(id)
	and not is_attacking(id)
	and not is_down(id)
	and not is_running(id)
	and not is_stunned(id)
end

local function stop(self)
	log("stop")
	self.running = false
	self.speed.x = 0
	self.speed.y = 0
	self.current_max_speed = self.initial_max_speed
	self.current_speed_lerp = self.initial_speed_lerp
end

local function play_flipbook(self, name)
	local animation = self.champ_data[name]
	if self.current_animation ~= animation then
		log("playing", animation)
		self.current_animation = animation
		sprite.play_flipbook("#sprite", animation)
	end
end

local function disable(url)
	msg.post(url, "disable")
end

local function enable(url)
	msg.post(url, "enable")
end

local function enable_side(self, left, right)
	msg.post(self.direction.x == -1 and left or right, "enable")
end

local function update_sprite_flip(self)
	sprite.set_hflip("#sprite", self.direction.x == -1)
end

local function update_hud(self)
	msg.post("hud", "champ", {
		id = self.id,
		champ = self.champ,
		boost = self.current_boost / self.max_boost,
		health = self.current_stamina / self.initial_stamina,
		health_max = self.max_stamina / self.initial_stamina,
		in_ring = self.in_ring,
	})
end

local function direction(go1, go2)
	local diff = go.get_position(go2) - go.get_position(go1)
	if vmath.length(diff) == 0 then
		return V3_ZERO
	else
		return vmath.normalize(diff)
	end
end

local function increase_boost(self, amount)
	self.current_boost = math.min(self.current_boost + amount, self.max_boost)
	update_hud(self)
end

local function throw_champ(self)
	if is_lifting_champ(id) then
		sequence.run_once(function()
			log("throw")
			sounds.thud()
			increase_boost(self, BOOST_THROW)
			local pos = go.get_position()
			local champ = self.lifting_champ
			self.lifting_champ = nil
			go.set_parent(champ, nil, true)
			if self.direction.x ~= 0 then
				go.animate(champ, "position.x", go.PLAYBACK_ONCE_FORWARD, pos.x + 40 * self.direction.x, go.EASING_OUTQUAD, 0.35)
				go.animate(champ, "position.y", go.PLAYBACK_ONCE_FORWARD, pos.y, go.EASING_OUTBOUNCE, 0.35)
			else
				go.animate(champ, "position.y", go.PLAYBACK_ONCE_FORWARD, pos.y + 40 * self.direction.y, go.EASING_OUTBOUNCE, 0.35)
			end
			sequence.delay(0.35)
			msg.post(champ, MSG_THROWN)
		end)
	end
end

local function lift_champ(self, champ)
	log("lifing champ")
	msg.post(champ, MSG_LIFTED)
	self.lifting_champ = champ
	go.set_parent(champ, go.get_id(), false)
	go.set_position(vmath.vector3(0, 14, 0), champ)
end

local function climb_ring_post(self, post)
	sequence.run_once(function()
		if is_lifting_champ() then
			throw_champ(self)
		end
		increase_boost(self, BOOST_CLIMB_RING_POST)
		self.busy = true
		self.on_ring_post = true
		self.ring_post_id = post
		stop(self)
		local to = go.get_world_position(post) + vmath.vector3(0, 5, 0)
		sequence.go_animate(".", "position", go.PLAYBACK_ONCE_FORWARD, to, go.EASING_LINEAR, 0.2)
		disable("#shadow")
		disable("#champcollider")
		self.busy = false
	end)
end

local function jump_from_ring_post(self)
	enable("#champcollider")
	sequence.run_once(function()
		self.jumping = true
		self.on_ring_post = false

		play_flipbook(self, "back")

		-- jump animation
		-- different easings on x and y will make the movement in an arc instead of
		-- a straight line
		local to = go.get_position()
		local dir = POST_TO_DIRECTION[self.ring_post_id]
		to = to - dir * 30
		if dir.y < 0 then
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, to.x, go.EASING_LINEAR, 0.2)
			go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, to.y, go.EASING_OUTQUAD, 0.2)
		else
			go.animate(".", "position.x", go.PLAYBACK_ONCE_FORWARD, to.x, go.EASING_LINEAR, 0.2)
			go.animate(".", "position.y", go.PLAYBACK_ONCE_FORWARD, to.y, go.EASING_INQUAD, 0.2)
			sprite.set_vflip("#sprite", true)
		end
		sequence.delay(0.2)

		-- bounce when landing and enable special attack
		sounds.thud()
		to = to + vmath.vector3(0,5,0)
		enable("#specialattack")
		self.attacking = true
		sequence.go_animate(".", "position", go.PLAYBACK_ONCE_PINGPONG, to, go.EASING_INOUTQUAD, 0.1)
		self.attacking = false
		disable("#specialattack")

		-- delay before standing up
		sequence.delay(0.5)
		sprite.set_vflip("#sprite", false)
		enable("#shadow")
		self.jumping = false
	end)
end

local function handle_action(self, action_id, action)
	self.state.on_input(action_id, action)

	if is_stunned() or is_down() then
		return
	end

	local now = socket.gettime()

	-- run
	if actions.is_movement(action_id) and not is_on_ring_post() and action.pressed then
		-- stop running if trying to move again in other direction
		if is_running() then
			if self.speed.x > 0 and action_id ~= actions.RIGHT
			or self.speed.x < 0 and action_id ~= actions.LEFT
			or self.speed.y > 0 and action_id ~= actions.UP
			or self.speed.y < 0 and action_id ~= actions.DOWN then
				stop(self)
			end
		end
		-- double tap to run
		if self.last_action == action_id and (now - self.last_action_time) < 0.3 then
			log("run")
			sequence.run_once(function()
				self.running = true
				self.current_max_speed = self.initial_max_speed * RUN_RATIO
				self.speed = actions.direction(action_id) * self.current_max_speed
				self.current_speed_lerp = 0
				if self.run_timer then
					timer.cancel(self.run_timer)
				end
			end)
		end
	-- punch
	elseif action_id == actions.A then
		if action.pressed then
			local nearby = next(self.nearby)
			if is_lifting_champ() then
				throw_champ(self)
			elseif nearby and is_down(nearby) then
				lift_champ(self, nearby)
			elseif is_on_ring_post() then
				jump_from_ring_post(self)
			else
				log("punch")
				sequence.run_once(function()
					if is_attacking() then
						log("punch - already attacking")
						return
					end
					if not is_running() then
						stop(self)
					end
					self.attacking = true
					sounds.miss()
					enable_side(self, "#leftattack", "#rightattack")
					play_flipbook(self, "punch")
					sequence.go_animate(".", "position", go.PLAYBACK_ONCE_FORWARD, go.get_position() + self.direction * 5, go.EASING_INQUAD, 0.1)
					sequence.delay(0.1)
					disable("#leftattack")
					disable("#rightattack")
					self.attacking = false
				end)
			end
		end
	elseif action_id == actions.B then
		if action.pressed then
			local nearby = next(self.nearby)
			if not nearby then
				log("taunt")
				sequence.run_once(function()
					increase_boost(self, BOOST_TAUNT)
					self.busy = true
					play_flipbook(self, "taunt")
					sequence.delay(1)
					self.busy = false
				end)
			elseif is_down(nearby) then
				-- pin opponent
			end
			--[[sequence.run_once(function()
				self.attacking = true
				stop(self)
				enable_side(self, "#leftattack", "#rightattack")
				play_flipbook(self, "kick")
				sequence.delay(1.0)
				disable("#leftattack")
				disable("#rightattack")
				self.attacking = false
			end)--]]
		end
	end

	-- update last action
	if action.pressed then
		self.last_action_time = now
		self.last_action = action_id
	end
end

local function start_ai(self)
	local target = nil
	sequence.run_loop(function()
		if is_down() then
			sequence.delay(0.5)
			return
		end
		
		if not target then
			target = CHAMPS[math.random(1, #CHAMPS)]
			if target.id == go.get_id() or is_down(target.id) or is_on_ring_post(target.id) then
				target = nil
			end
		end
		if not target then
			sequence.delay(0.5)
			return
		end

		local pos = go.get_position()
		local target_pos = go.get_position(target.id)
		local diff = target_pos - pos
		local distance = vmath.length(diff)
		local dir = vmath.normalize(diff)
		if distance < 15 or is_on_ring_post() then
			handle_action(self, actions.LEFT, actions.ACTION_RELEASED)
			handle_action(self, actions.RIGHT, actions.ACTION_RELEASED)
			target = nil
			handle_action(self, actions.A, actions.ACTION_PRESSED)
			handle_action(self, actions.A, actions.ACTION_RELEASED)
		elseif math.random(1,10) == 9 then
			handle_action(self, actions.B, actions.ACTION_PRESSED)
			handle_action(self, actions.B, actions.ACTION_RELEASED)
		else
			if dir.x > 0 then
				handle_action(self, actions.RIGHT, actions.ACTION_PRESSED)
				handle_action(self, actions.LEFT, actions.ACTION_RELEASED)
			elseif dir.x < 0 then
				handle_action(self, actions.LEFT, actions.ACTION_PRESSED)
				handle_action(self, actions.RIGHT, actions.ACTION_RELEASED)
			else
				handle_action(self, actions.LEFT, actions.ACTION_RELEASED)
				handle_action(self, actions.RIGHT, actions.ACTION_RELEASED)
			end
			if dir.y > 0 then
				handle_action(self, actions.UP, actions.ACTION_PRESSED)
				handle_action(self, actions.DOWN, actions.ACTION_RELEASED)
			elseif dir.y < 0 then
				handle_action(self, actions.DOWN, actions.ACTION_PRESSED)
				handle_action(self, actions.UP, actions.ACTION_RELEASED)
			else
				handle_action(self, actions.UP, actions.ACTION_RELEASED)
				handle_action(self, actions.DOWN, actions.ACTION_RELEASED)
			end
		end
		sequence.delay(0.25)
	end)
end

local function regenerate_damage(self, dt)
	local ratio = self.max_stamina / self.initial_stamina
	if is_down() and self.max_stamina > 0 then
		self.current_stamina = math.min(self.current_stamina + 10 * ratio * dt, self.max_stamina)
		if self.current_stamina == self.max_stamina then
			play_flipbook(self, "idle")
			self.down = false
		end
	else
		self.current_stamina = math.min(self.current_stamina + 3 * ratio * dt, self.max_stamina)
		--self.max_stamina = math.min(self.max_stamina + 1 * ratio * dt, self.initial_stamina)
	end
	update_hud(self)
end

local function take_damage(self, amount, source, props)
	if self.down then
		return
	end
	self.current_stamina = math.max(self.current_stamina - amount, 0)
	if self.current_stamina == 0 then
		self.max_stamina = math.max(self.max_stamina - self.initial_stamina * 0.2, 0)
		sequence.run_once(function()
			log("down")
			self.down = true
			throw_champ(self)
			play_flipbook(self, "down")
		end)
	end
	update_hud(self)
	sounds.cheer()

	-- stun
	sequence.run_once(function()
		self.stunned = true
		local left = (go.get_position() - go.get_position(source)).x > 0
		enable(left and "#lefthit" or "#righthit")
		sequence.delay(0.25)
		disable(left and "#lefthit" or "#righthit")
		self.stunned = false
	end)

	-- pushback
	sequence.run_once(function()
		self.current_max_speed = self.initial_max_speed * 6
		self.current_speed_lerp = 0
		self.speed = (props.pushback or V3_ONE) * self.current_max_speed
		sequence.delay(0.10)
		self.current_speed_lerp = self.initial_speed_lerp
		self.current_max_speed = self.initial_max_speed
	end)

	msg.post("game", "damage", { amount = amount })
end

function init(self)
	log = logger.create("[champ_" .. self.id .. "]")
	log(self.player, self.id, self.champ)
	CHAMPS[go.get_id()] = self
	CHAMPS[#CHAMPS + 1] = { id = go.get_id(), instance = self }
	self.nearby = {}
	self.in_ring = false
	self.last_action_time = nil
	self.last_action = nil
	self.direction = directions.NONE
	self.state = state.create()
	self.speed = vmath.vector3()
	self.current_speed_lerp = self.initial_speed_lerp
	self.current_max_speed = self.initial_max_speed
	self.current_stamina = self.initial_stamina
	self.max_stamina = self.initial_stamina
	self.current_boost = 0
	self.max_boost = 100
	self.champ_data = champs.get(self.champ)
	disable("#leftattack")
	disable("#rightattack")
	disable("#lefthit")
	disable("#righthit")
	disable("#specialattack")
	if self.player then
		msg.post(".", "acquire_input_focus")
	end
	sequence.run_once(function()
		sequence.delay(math.random() * 0.25)
		play_flipbook(self, "idle")
	end)
	update_hud(self)

	if not self.player then
		start_ai(self)
	end
end

function final(self)
	-- Add finalization code here
	-- Remove this function if not needed
end

function update(self, dt)
	regenerate_damage(self, dt)
	local can_move = not is_attacking() and not is_stunned() and not is_down() and not is_on_ring_post() and not is_busy()
	if self.state.is_pressed(actions.LEFT) and can_move then
		self.speed.x = self.speed.x - self.acceleration * dt
		self.direction = directions.LEFT
		update_sprite_flip(self)
	elseif self.state.is_pressed(actions.RIGHT) and can_move then
		self.speed.x = self.speed.x + self.acceleration * dt
		self.direction = directions.RIGHT
		update_sprite_flip(self)
	else
		self.speed.x = vmath.lerp(self.current_speed_lerp, self.speed.x, 0)
	end

	if self.state.is_pressed(actions.UP) and can_move then
		self.speed.y = self.speed.y + self.acceleration * dt
		self.direction = directions.UP
	elseif self.state.is_pressed(actions.DOWN) and can_move then
		self.speed.y = self.speed.y - self.acceleration * dt
		self.direction = directions.DOWN
	else
		self.speed.y = vmath.lerp(self.current_speed_lerp, self.speed.y, 0)
	end

	if not is_attacking() and not is_jumping() then
		if is_on_ring_post() then
			play_flipbook(self, "taunt")
		elseif is_idle() then
			play_flipbook(self, is_lifting_champ() and "idle_lifting" or "idle")
		elseif is_moving() then
			--log("WALK DAMMIT", self.speed)
			play_flipbook(self, is_lifting_champ() and "walk_lifting" or "walk")
		end
	end

	-- clamp to max speed
	self.speed.x = util.clamp(self.speed.x, -self.current_max_speed, self.current_max_speed)
	self.speed.y = util.clamp(self.speed.y, -self.current_max_speed, self.current_max_speed)

	local pos = go.get_position()
	pos = pos + self.speed * dt
	pos.z = 1 - pos.y / 640
	if is_on_ring_post() then
		pos.z = pos.z + 5
	end
	go.set_position(pos)
	update_hud(self)
end

function on_message(self, message_id, message, sender)
	if message_id == MSG_CONTACT_POINT_RESPONSE then
		-- this champ ran into the rope
		if message.other_group == GROUP_ROPE then
			if is_on_ring_post() or is_jumping() then
				return
			end
			if self.in_ring then
				if message.distance > 0 then
					-- bounce on the rope
					if is_running() then
						increase_boost(self, BOOST_BOUNCE_ROPE)
						-- increase speed and animate back to previous speed
						local current_max_speed = self.current_max_speed
						self.current_max_speed = self.initial_max_speed * ROPE_BOUNCE_RATIO
						go.animate("#", "current_max_speed", go.PLAYBACK_ONCE_FORWARD, current_max_speed, go.EASING_LINEAR, 0.5)
						-- flip direction
						local horizontal = math.abs(message.normal.x) > math.abs(message.normal.y)
						if horizontal then
							self.speed.x = (message.normal.x > 0) and self.current_max_speed or -self.current_max_speed
							self.direction = (message.normal.x > 0) and directions.RIGHT or directions.LEFT
							update_sprite_flip(self)
						else
							self.speed.y = (message.normal.y > 0) and self.current_max_speed or -self.current_max_speed
							self.direction = (message.normal.y > 0) and directions.UP or directions.DOWN
						end
						-- stop running after a certain period of time has elapsed
						self.run_timer = timer.delay(0.6, false, function()
							stop(self)
							self.running = false
						end)
					-- stop at the rope
					else
						go.set_position(go.get_position() + message.normal * message.distance)
					end
				end
			-- get back into ring
			else
				local pos = go.get_position()
				pos = pos + message.normal * 30
				go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, pos, go.EASING_INOUTQUAD, 0.4)
			end
		-- this champ hit another champ
		elseif message.own_group == GROUP_ATTACK
		and message.other_group == GROUP_CHAMP
		and is_attacking() then
			local dir = direction(go.get_id(), message.other_id)
			if is_running() then
				log("clothesline!")
				sounds.punch()
				increase_boost(self, BOOST_SPECIAL_DAMAGE)
				msg.post(message.other_id, MSG_DAMAGE, { amount = 30, pushback = dir })
			else
				log("hit!")
				sounds.punch()
				increase_boost(self, BOOST_NORMAL_DAMAGE)
				msg.post(message.other_id, MSG_DAMAGE, { amount = 10, pushback = dir })
				stop(self)
			end
			self.attacking = false
		-- this champ hit another champ with a special attack
		elseif message.own_group == GROUP_SPECIAL
		and message.other_group == GROUP_CHAMP
		and message.other_id ~= go.get_id() then
			sounds.punch()
			increase_boost(self, BOOST_SPECIAL_DAMAGE)
			msg.post(message.other_id, MSG_DAMAGE, { amount = 50 })
			self.attacking = false
		elseif message.other_group == GROUP_POST then
			if not is_on_ring_post() then
				climb_ring_post(self, message.other_id)
			end
		end
	elseif message_id == MSG_TRIGGER_RESPONSE then
		-- nearby another champ
		if message.other_group == GROUP_CHAMP then
			if go.get_id() ~= message.other_id then
				if message.enter then
					self.nearby[message.other_id] = true
				else
					self.nearby[message.other_id] = nil
				end
			end
		-- inside ring
		elseif message.other_group == GROUP_RING then
			self.in_ring = message.enter
		end
	elseif message_id == MSG_DAMAGE then
		take_damage(self, message.amount, sender, message)
	elseif message_id == MSG_LIFTED then
		log("lifted")
		disable("#shadow")
		disable("#champcollider")
		self.lifted = true
	elseif message_id == MSG_THROWN then
		log("thrown")
		enable("#shadow")
		enable("#champcollider")
	end
end

function on_input(self, action_id, action)
	action_id = mapper.on_input(action_id, self.id)
	handle_action(self, action_id, action)
end

function on_reload(self)
	-- Add reload-handling code here
	-- Remove this function if not needed
end
